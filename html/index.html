<html>
    <head>
      <title>Ternary Tree: Structured Associative Containers</title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
<style>
/* must override a few items to get the style background color */
HR { background-color: #e09060; }
..memproto {
  background-color: #fbf8d0; 
  border-color: #e09060;
}
</style>
    </head>
    <body>
<table width="100%" style="font-weight: bold; background-color: #fbf8d0; padding: 0.3em;"><tr><td>
<a style="text-decoration: none;" href="index.html">Overview</a>&nbsp;&nbsp;&nbsp;&nbsp;
<!--a style="text-decoration: none;" href="classcontainers_1_1ternary__tree.html">Ternary Search Tree</a >&nbsp;&nbsp;&nbsp;&nbsp;-->
<a style="text-decoration: none;" href="tst_usage.html">Usage</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a style="text-decoration: none;" href="perf_notes.html">Performance Notes</a>&nbsp;&nbsp;&nbsp;&nbsp;
<!--a style="text-decoration: none;" href="tst_impl.html">Implementation Details</a>&nbsp;&nbsp;&nbsp;&nbsp;-->
<a style="text-decoration: none;" href="tst_links.html">Links</a></td>
<td align="right" style="font-weight: normal; font-style: italic; color: #606080;">tst 0.68 - 23 Jan 2009</td>
</tr></table>
<hr style="height: 3px;">
<!-- Generated by Doxygen 1.5.6 -->
<div class="contents">
<h1>Structured Associative Containers</h1>
<p>
Ternary Search Tree <a class="el" href="namespacecontainers.html">containers</a> to replace <code>set&lt;string&gt;</code> and <code>map&lt;string, Value&gt;</code> <center><table bgcolor="#fbf9e5" style="border: thin dotted #808000;" width="95%" border="0>" cellspacing="3" cellpadding="3">
<tr>
<td><h3>Table of contents</h3>
<p>
<dl>
<dt><a class="el" href="index.html#introduction">Introduction</a> </dt>
<dd></dd>
<dt><a class="el" href="index.html#subkey_search_overview">Advanced searches overview</a> </dt>
<dd></dd>
<dt><a class="el" href="tst_usage.html">Tutorial</a> </dt>
<dd></dd>
<dt><a class="el" href="tst_reference.html">Reference</a> </dt>
<dd><a class="el" href="structured_concept.html">Structured Container concept</a> <br>
 Class <a class="el" href="classcontainers_1_1structured__set.html">structured_set</a> <br>
 Class <a class="el" href="classcontainers_1_1structured__map.html">structured_map</a> <br>
 Class <a class="el" href="classcontainers_1_1structured__multiset.html">structured_multiset</a> <br>
 Class <a class="el" href="classcontainers_1_1structured__multimap.html">structured_multimap</a> <br>
 Implementation class <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>  </dd>
<dt><a class="el" href="perf_notes.html">Performance notes</a> </dt>
<dd></dd>
<dt><a class="el" href="tst_impl.html">Implementation details</a> </dt>
<dd></dd>
<dt><a class="el" href="tst_links.html">Links</a> </dt>
<dd></dd>
<dt><a class="el" href="tst_tests.html">Test Suite</a> </dt>
<dd></dd>
</dl>
</td></tr>
</table>
</center><p>
Download: Latest version (0.684) <a href="http://abc.se/~re/code/tst/ternary_tree.zip">http://abc.se/~re/code/tst/ternary_tree.zip</a><br>
<p>
Copyleft: <a href="mailto:rasmus%20point%20ekman%20at%20abc%20point%20se?subject=Structured Containers suck/rule">rasmus ekman</a> 2007-2009 <br>
 Weblink: <a href="http://abc.se/~re/code/tst">http://abc.se/~re/code/tst</a><p>
<a class="anchor" name="introduction"></a> <hr>
 <h2>Introduction</h2>
<p>
<b>Structured <a class="el" href="namespacecontainers.html">containers</a></b> are <code>map</code> and <code>set</code> -like <a class="el" href="namespacecontainers.html">containers</a> specialized for strings. They are commonly used for dictionaries.<br>
 Structured <a class="el" href="namespacecontainers.html">containers</a> have two major benefits:<ul>
<li>They offer near-match searches (wildcard search, partial match etc) that are hard to implement with other <a class="el" href="namespacecontainers.html">containers</a>.</li><li>Lookup performance is on a par with hashed <a class="el" href="namespacecontainers.html">containers</a> for many common applications, and 2-5 times faster than standard maps and sets (with string-like keys).</li></ul>
<p>
Of course there is a price to pay: structured <a class="el" href="namespacecontainers.html">containers</a> use much more memory than other <a class="el" href="namespacecontainers.html">containers</a>: Around 6-8 bytes <b>per letter</b> inserted (whether <code>char</code> or <code>wchar_t</code>); an English 150 k word dictionary uses eg 7.3 MB to store 1.2 MB words (2.4 MB of <code>wchar_t</code> words).<p>
The container classes in this library can be used as drop-in replacements for <code>set</code> and <code>map</code> (or <code>unordered_set</code>, <code>unordered_map</code>):<ul>
<li><a class="el" href="classcontainers_1_1structured__set.html">structured_set</a>: This stores unique keys and allows structured key searches.</li><li><a class="el" href="classcontainers_1_1structured__multiset.html">structured_multiset</a>: This stores non-unique keys.</li><li><a class="el" href="classcontainers_1_1structured__map.html">structured_map</a>: This is a <a href="http://www.sgi.com/tech/stl/PairAssociativeContainer.html" target="sgi">Pair Associative Container</a>, as it allows associating a value with each key.</li><li><a class="el" href="classcontainers_1_1structured__multimap.html">structured_multimap</a>: Technically, a <a href="http://www.sgi.com/tech/stl/MultipleSortedAssociativeContainer.html" target="sgi">Multiple, Sorted, Pair Associative Container</a> - it allows storing several values with each key.</li></ul>
<p>
While the STL standard associative <a class="el" href="namespacecontainers.html">containers</a> are normally backed by a binary tree structure, Structured Containers are backed by a Ternary Search Tree, as presented by <a class="el" href="tst_links.html#note_1">Jon Bentley and Robert Sedgewick in [1]</a>.<p>
Class <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree&lt;Key, Value, Comp, Alloc&gt;</a> provides the implementation backend. Due to its internals, its interface cannot easily be made to conform with standard STL concepts, so it is used internally by the structured* wrapper classes (much like STL's internal <code>rb_tree</code> class).<p>
Basically, if you have code using sets or maps, you have code to use structured <a class="el" href="namespacecontainers.html">containers</a>. And with 1-3 lines of code, you're ready to make advanced imprecise searches in your dictionaries.<br>
 See <a class="el" href="tst_usage.html">the usage section</a> for examples of how to use these classes.<p>
<table bgcolor="#f0f0ff" style="border: thin dotted #808000;" border="0>" cellspacing="3" cellpadding="3">
<tr>
<th>Library status </th></tr>
<tr>
<td valign="top" align="right">Compatibility: </td><td>Note that the file <b>tst_concept_checks.cpp</b> is currently broken. Will investigate.<br>
<p>
</td></tr>
<tr>
<td valign="top" align="right">version&nbsp;0.684: (Jan 2009) </td><td>Fix standard-breakage in multimap/multiset return from <code>insert(const value_type&amp;)</code>.<br>
 Added <code>operator-&gt;</code> to iterator wrapper for C++0x compatibility. Thanks to Geoffrey Noel for reports.  </td></tr>
<tr>
<td valign="top" align="right">version&nbsp;0.683: (March 2007) </td><td>Fix portability issues for GCC and non-STLport libraries. Fix longest_match.<br>
 Thanks to Arjen Wagenaar for several reports, fixes and encouragement. Thanks also to Michel Tourn for reports.  </td></tr>
<tr>
<td valign="top" align="right">version&nbsp;0.68: (Dec 2006) </td><td>Implement TST_NODE_COUNT_TYPE macro, which can be used to control node size on 64-bit systems. See <a class="el" href="classcontainers_1_1ternary__tree.html">class ternary_tree</a>  </td></tr>
<tr>
<td valign="top" align="right">version&nbsp;0.68&nbsp;(alpha): </td><td>Reimplemented node type. Do proper management of value type (was inconsistent, partly unimplemented - duh!) <p>
</td></tr>
</table>
<p>
<a class="anchor" name="subkey_search_overview"></a> <hr>
 <h2>Sub-key, or Structure Searches</h2>
<p>
<span style="color:#905050;">(a new interface for these searches will be specified in the future)</span><p>
Ternary trees allow searches that match parts of keys and ignores mismatches in other parts.<br>
 In the current interface we specify a small number of searches facilitated by the tree structure; the Partial Match and Hamming searches are defined in several other implementations (showcased in <a class="el" href="tst_links.html#note_1">Bentley and Sedgewick</a> code). The Levenshtein and combinatorial searches are not found in other ternary trees (that I know of).<p>
<table border="1" cellspacing="0" cellpadding="3">
<tr>
<th bgcolor="#f0f0ff">Name (function name)</th><th bgcolor="#f0f0ff">Description </th></tr>
<tr>
<th>Prefix match (<a class="el" href="classcontainers_1_1ternary__tree.html#d3a2e52c87d13662bfc39c58e047a3b2">prefix_range</a>)</th><td>Finds keys sharing a common prefix, returns a pair of <a class="el" href="namespaceiterators.html">iterators</a>. </td></tr>
<tr>
<th>Longest match (<a class="el" href="classcontainers_1_1ternary__tree.html#63252eb2273c6824f50894652b99ed86">longest_match</a>)</th><td>Finds the longest key that matches beginning of search string. A typical application is to tokenize a string using the ternary tree as dictionary. </td></tr>
<tr>
<th>Partial match, or wildcard search (<a class="el" href="classcontainers_1_1ternary__tree.html#8c63d4ad36f66355803cfcedec5f61ad">partial_match_search</a>)</th><td>Accepts a search string with wildcard characters that will match any letter, eg "b?nd" would match "band", "bend", "bind", "bond" in an English dictionary. </td></tr>
<tr>
<th>Search allowing <code>N</code> mismatches, (<a class="el" href="classcontainers_1_1ternary__tree.html#271002d995ff11ea86157acfbbb32c70">hamming_search</a><span style="font-weight:normal;"></span>)</th><td>Accepts a search string and an integer <code>dist</code> indicating how many non-matching letters are allowed, then finds keys matching search string that have at most <em>dist</em> mismatches. This works like a partial match search with all combinations of <em>dist</em> wildcards in the search string.<br>
 <code>hamming_search</code>("band", 1) matches the wildcard search plus "bald", "bane" and "wand", etc. <br>
 The version here, following DDJ code, extends the strict Hamming search by also allowing shorter and longer strings; a search for "band", <em>dist</em> = 1, also finds "ban" and "bandy" etc.<br>
 See also <a href="http://wikipedia.org/wiki/Hamming_distance">http://wikipedia.org/wiki/Hamming_distance</a> </td></tr>
<tr>
<th>Levenshtein distance search (<a class="el" href="classcontainers_1_1ternary__tree.html#1a065731747766b371dbc8b2dd13a5ea">levenshtein_search</a> <span style="font-weight:normal;">- consider descriptive name</span>)</th><td><p>
Hamming search matches characters in fixed position, allowing substitution of <em>dist</em> chars. Levenshtein search also allows shifting parts of the search string by insertion or skipping chars (in <em>dist</em> places). So&nbsp;<code>levenshtein_search("band", 1) </code> extends the hamming_search set with "and" and "bland", etc. A typical application is to match mispelt words.<br>
 See also <a href="http://wikipedia.org/wiki/Levenshtein_distance">http://wikipedia.org/wiki/Levenshtein_distance</a> </td></tr>
<tr>
<th>Combinatorial or "scrabble" search (<a class="el" href="classcontainers_1_1ternary__tree.html#8ec10f2049b8c459ad1c0f0ba9d41623">combinatorial_search</a>)</th><td>Finds all keys using the characters in search string. <code>combinatorial_search</code>("band") finds "ad", "and", "bad", "dab", "nab", etc. A count of wildcards can be added, also allowing nonmatching characters (use with care, values over 10% of average key length may cause the algorithm to traverse a large part of the tree). </td></tr>
</table>
<p>
See <a class="el" href="tst_usage.html#usage_imprecise_searches">advanced search overview</a> in the tutorial.<p>
These searches are defined for all <a class="el" href="namespacecontainers.html">containers</a> in this library. But they are also marked as deprecated (to be replaced by generic algorithms with same interface). For a relative performance comparison of imprecise searches, see the second table in <a class="el" href="perf_notes.html">Performance Notes</a>.<p>
<h3>Future directions</h3>
<p>
The searches currently defined are clearly special cases in a sea of search possibilities. We have only defined searches that are relatively efficient, compared to other combinations of <a class="el" href="namespacecontainers.html">containers</a> and algorithms. But there can be many variations on the available searches: increasing Hamming/Levenshtein distance at the end of words, or matching limited ranges of characters (eg allowing mismatches only in vowels), etc.<p>
The next step for this project is to support a more flexible low-level interface for traversing and filtering tree nodes. The interface for these "structured searches" is open for consideration, but it will basically define sub-key <a class="el" href="namespaceiterators.html">iterators</a>, conversion of full-key from sub-key <a class="el" href="namespaceiterators.html">iterators</a>, and a small collection of algorithms operating on these sub-key <a class="el" href="namespaceiterators.html">iterators</a>.<p>
At least the following operations are needed:<p>
<ul>
<li>sub-key match: matching a part of a key (prefix, or starting from current char position)</li><li>key element range increment: from a sub-key position, match a range of characters in next position (returns a list of sub-key <a class="el" href="namespaceiterators.html">iterators</a>? - or iterator-like operation?)</li><li>conversion from sub-key iterator to full-key iterator range (nearest and post-furthest keys in the subtree)</li><li><code>is_key(subkey_iterator pos)</code>: true if end-of-key exists at iterator position.</li><li><code>count_elements(subkey_iterator pos)</code>: returns number of available key elements at position.</li><li>In all predefined algorithms above, either a specific, or any char is matched, we would also support arbitrary char sets (possibly with special case for char ranges). </li></ul>
</div>
<hr style="height: 3px; border-top: 0px; background-color: #e09060;">
<table width="100%"><tr style="color: #606080; font-size: 90%;" border="0">
<td><em>ternary_tree 0.68 -- by rasmus ekman
-- Page generated with <a href="http://doxygen.org">Doxygen 1.5.6</a> on 23 Jan 2009</em></td>
<td style="text-align: right; color:#f0f0ff;"><!--#exec cgi="/cgi-bin/counter"--></td>
</tr></table>
</body>
</html>
