<html>
    <head>
      <title>Ternary Tree: ternary_tree Class Template Reference</title>
      <link href="doxygen.css" rel="stylesheet" type="text/css">
<style>
/* must override a few items to get the style background color */
HR { background-color: #e09060; }
..memproto {
  background-color: #fbf8d0; 
  border-color: #e09060;
}
</style>
    </head>
    <body>
<table width="100%" style="font-weight: bold; background-color: #fbf8d0; padding: 0.3em;"><tr><td>
<a style="text-decoration: none;" href="index.html">Overview</a>&nbsp;&nbsp;&nbsp;&nbsp;
<!--a style="text-decoration: none;" href="classcontainers_1_1ternary__tree.html">Ternary Search Tree</a >&nbsp;&nbsp;&nbsp;&nbsp;-->
<a style="text-decoration: none;" href="tst_usage.html">Usage</a>&nbsp;&nbsp;&nbsp;&nbsp;
<a style="text-decoration: none;" href="perf_notes.html">Performance Notes</a>&nbsp;&nbsp;&nbsp;&nbsp;
<!--a style="text-decoration: none;" href="tst_impl.html">Implementation Details</a>&nbsp;&nbsp;&nbsp;&nbsp;-->
<a style="text-decoration: none;" href="tst_links.html">Links</a></td>
<td align="right" style="font-weight: normal; font-style: italic; color: #606080;">tst 0.68 - 23 Jan 2009</td>
</tr></table>
<hr style="height: 3px;">
<!-- Generated by Doxygen 1.5.6 -->
  <div class="navpath"><a class="el" href="namespacecontainers.html">containers</a>::<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>
  </div>
<div class="contents">
<h1>ternary_tree Class Template Reference</h1><!-- doxytag: class="containers::ternary_tree" -->
<p>
<a href="classcontainers_1_1ternary__tree-members.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class StringT, class DataT, class CompT = std::less&lt;typename StringT::value_type&gt;, class AllocT = std::allocator&lt;DataT&gt;&gt;<br>
 class containers::ternary_tree&lt; StringT, DataT, CompT, AllocT &gt;</h3>

Ternary search tree (trie) is a sorted container for strings, with advanced search possibilities (wildcard and near-match searches), and fast lookup (similar to hash_map, 3-6 times faster than map) - It is typically used for dictionaries. 
<p>
A ternary tree is a Structured Associative Container. This means that its key type is required to be a Forward Container, and that the tree uses a comparator to establish a strict weak ordering among <code>key::value_type</code> elements (rather than on whole keys). This allows searches involving parts of keys, ie with shared prefix or with shared middle parts.<p>
<a class="el" href="classcontainers_1_1ternary__tree.html" title="Ternary search tree (trie) is a sorted container for strings, with advanced search...">ternary_tree</a> is a Unique Associative Container. Note that it is <b>not</b> Pair Associative, so the value that is returned when dereferencing an iterator is not a <code>std::pair&lt;const Key, Data&gt;</code> as for map or unsorted_map. Instead the Data value is returned. To get the key that a <a class="el" href="classcontainers_1_1ternary__tree.html" title="Ternary search tree (trie) is a sorted container for strings, with advanced search...">ternary_tree</a> iterator is positioned at, iterator specifies member function key() - see <a class="el" href="structcontainers_1_1tst__detail_1_1iter__method__forward.html" title="Helper template that forwards the key(), value() public methods from tst_iterator_base...">tst_detail::iter_method_forward</a>.<p>
<a class="el" href="classcontainers_1_1ternary__tree.html" title="Ternary search tree (trie) is a sorted container for strings, with advanced search...">ternary_tree</a> is a Sorted, and thus by implication a Reversible Container. While iteration is amortized constant time, it is often slower than other Associative <a class="el" href="namespacecontainers.html">containers</a> since it must walk several key element nodes to find next key endnode. The iteration cost factor is proportional to <a class="el" href="classcontainers_1_1ternary__tree.html#546844ddc1b7c0805b66d6f5690191d9" title="Returns number of nodes in tree.">node_count()</a> / <a class="el" href="classcontainers_1_1ternary__tree.html#a1cb98c99c5fa5904f0a2ad698a7a299" title="Returns sum of lengths of all keys inserted into tree.">total_key_length()</a>.<p>
<h3>Exception safety</h3>
<p>
<a class="el" href="classcontainers_1_1ternary__tree.html" title="Ternary search tree (trie) is a sorted container for strings, with advanced search...">ternary_tree</a> generally conforms to standard Associative Container exception guarantees:<ul>
<li><a class="el" href="classcontainers_1_1ternary__tree.html#c8bb3912a3ce86b15842e79d0b421204">clear()</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#e57ff6dd1cb4dc347b892dfa87ea6613" title="Makes key unreachable, but usually does not reclaim nodes to memory pool.">erase()</a> operations do not throw an exception.</li><li>no <a class="el" href="classcontainers_1_1ternary__tree.html#3c8c26880a8fd44ae8d40916c92be27e">swap()</a> operation throws an exception, unless thrown by the copy constructor of the key element Compare object.</li><li>If an exception is thrown by an <a class="el" href="classcontainers_1_1ternary__tree.html#bb5f272154877b5de78b68f7a98a5bb4" title="Returns a pair whose bool component returns true if an insertion was made and false...">insert()</a> operation while inserting a single element, that function has no effect.</li></ul>
<p>
<h3>Controlling macros</h3>
<p>
<ul>
<li><code>TST_NODE_COUNT_TYPE:</code> controls the count of nodes. On systems where std::size_t may be a 64-bit value, this can be set to a 32-bit unsigned type, if you know that the total count of characters inserted in the tree will not exceed its limits. If the macro is undefined, it defaults to <code>std::size_t</code>. Note that the macro is undefined internally in the tree, so no code except the node typedef uses it.</li><li>If <code>TST_USE_FASTMAP</code> is defined, a direct link to first-level symbol nodes is maintained internally. This provides no measurable improvement with 8-bit charsets, but the interested user can try it with 16-bit chars (and please report if you can measure it)</li></ul>
<p>
See further <a class="el" href="tst_impl.html">Implementation Details</a><p>
<h3>Balanced and unbalanced trees</h3>
<p>
It should be noted that insertion order affects tree performance: After sorted (lexicographical) insertion, lookup is sometimes 50-100% slower, while <a class="el" href="namespaceiterators.html">iterators</a> are (always) 50-90% faster than with random-order string insertion. There is currently no support for rebalancing the tree.<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classcontainers_1_1ternary__tree.html#06fc87d81c62e9abb8790b6e5713c55bf7dbaf16b7f870b00de8e49e96928da7">wildcard_char</a> =  char_type('?')
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default wildcard for partial_match_search.  <a href="classcontainers_1_1ternary__tree.html#06fc87d81c62e9abb8790b6e5713c55b">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef StringT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef StringT::value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef CompT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="class_data_t.html">DataT</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#73698ab9694a30d494a8bbcf67cb1869">value_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="class_data_t.html">DataT</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#28abbceceb418e111143996599f65a2b">mapped_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef AllocT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef AllocT::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#ee486410786d79e33e01d73ea6cca7da">pointer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef AllocT::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#1fdba14c8cbdf2b890a371b866e21a4d">const_pointer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef AllocT::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#fc70ed01177d84adef5112c04bebae10">reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef AllocT::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#3d091a348d155ec28fa408a61482055a">const_reference</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef AllocT::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#970890daea8e5934937d6ac81aa3192c">difference_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef AllocT::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef node::node_index&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dependent type, defined by the macro <code>TST_NODE_COUNT_TYPE</code> (default: size_type).  <a href="#37eb606af3dc858ec309f49233ec89b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::vector&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a>, <br>
typename <br>
allocator_type::template <br>
rebind&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a> &gt;::other &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#d881e5d84c7bb60a13cfa7c54df27507">NodeList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Impl note: nodes are stored in vector, effectively working as pool allocator. node_index vector offsets are used instead of pointers.  <a href="#d881e5d84c7bb60a13cfa7c54df27507"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
<a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_detail::tst_iterator_base</a><br>
&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#d881e5d84c7bb60a13cfa7c54df27507">NodeList</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#5e2aa25bfa0e4f8ac92e14b0301fd6de">string_type</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#fa33239da3bc144574b6858d80ce2630">tst_iterator_base</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">typedef tst_detail::tst_iterator_base&lt;StringT, DataT, CompT, AllocT&gt; tst_iterator_base;  <a href="#fa33239da3bc144574b6858d80ce2630"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
TST_ITERATOR_FACADE_BEGIN <br>
<a class="el" href="structiterators_1_1iterator__wrapper.html">iterators::iterator_wrapper</a><br>
&lt; <a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_iterator_base</a>, <br>
<a class="el" href="structiterators_1_1nonconst__traits.html">iterators::nonconst_traits</a><br>
&lt; <a class="el" href="class_data_t.html">value_type</a> &gt;<br>
 &gt; TST_ITERATOR_FACADE_END&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
TST_ITERATOR_FACADE_BEGIN <br>
<a class="el" href="structiterators_1_1iterator__wrapper.html">iterators::iterator_wrapper</a><br>
&lt; <a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_iterator_base</a>, <br>
<a class="el" href="structiterators_1_1const__traits.html">iterators::const_traits</a><br>
&lt; <a class="el" href="class_data_t.html">value_type</a> &gt;<br>
 &gt; TST_ITERATOR_FACADE_END&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::reverse_iterator<br>
&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#92b881db836646f4039adcbb73c8595f">reverse_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::reverse_iterator<br>
&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classcontainers_1_1search__results__list.html">search_results_list</a><br>
&lt; <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#a14e9b3d5874f4cabce058df161bf01b">search_results_list</a></td></tr>

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construct, copy, destroy</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#b9b69c7ac4c5994a342e5c200fd3cc50">ternary_tree</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a> &amp;comp=<a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a>(), const <a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a> &amp;alloc=<a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>())</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#c47c0d990e2e420e77b4ded99f23dd34">ternary_tree</a> (InputIterator first, InputIterator last, const <a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a> &amp;comp=<a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a>(), const <a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a> &amp;alloc=<a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>())</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#a2321b9c15742d4173a3b3fd4493eb0f">ternary_tree</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a> &amp;other)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#a0b22184ad6609cad86b2127e34b606d">~ternary_tree</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#d592db3b95b56fcad5871af996008c39">operator=</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a> &amp;other)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#cfbc5374e81f060b1cdffeb9c494ae86">get_allocator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the allocator used to construct the tree.  <a href="#cfbc5374e81f060b1cdffeb9c494ae86"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText">Includes C++0x methods cbegin, cend, crbegin, crend to make it easier to access const <a class="el" href="namespaceiterators.html">iterators</a>. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#d69bd11391be1a1dba5c8202259664f8">begin</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#a4b02d4f1a8500fb07a551069060709f">begin</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#350132543d80a1c1e5be844e6d2878ea">end</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#92b881db836646f4039adcbb73c8595f">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#cea44ed500a54b2bb93e16b86e81afa8">rbegin</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#04886aa70c34d66738e78bf70c675e66">rbegin</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#92b881db836646f4039adcbb73c8595f">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#68c599ddcbfddc65170de524ac165e44">rend</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#b3c414470d5cea2986cfab7a90146cb6">rend</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#bcbe5a8d1c228764829c9826cfe48910">cbegin</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#02ed5283a097925e2c2f96e6daae6a80">cend</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#d46fdce4a2ae356bce3b801db2bcc918">crbegin</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#0ec903d2e9ea165b0460f1f6d40da203">crend</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Capacity</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#c6e61de369e994009e36f344f99c15ad">empty</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#503ab01f6c0142145d3434f6924714e7">size</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#0ab5ce862c0331d9e45a6e1774fca131">max_size</a> () const </td></tr>

<tr><td colspan="2"><div class="groupHeader">Element access</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_data_t.html">mapped_type</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#ed8a0df9b61494f55f08fd3c7f7189fb">operator[]</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a key into the tree and returns a mutable reference to its mapped_value.  <a href="#ed8a0df9b61494f55f08fd3c7f7189fb"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifiers</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>, bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#bb5f272154877b5de78b68f7a98a5bb4">insert</a> (const std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a>, <a class="el" href="class_data_t.html">value_type</a> &gt; &amp;val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pair whose bool component returns true if an insertion was made and false if the tree already contained an an equivalent key.  <a href="#bb5f272154877b5de78b68f7a98a5bb4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIterator&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#2ccdc5ab3d59da403b2ad0f435f0599e">insert</a> (InputIterator first, InputIterator last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a range from another <a class="el" href="classcontainers_1_1ternary__tree.html" title="Ternary search tree (trie) is a sorted container for strings, with advanced search...">ternary_tree</a> (or any iterator to pair with same key_type, mapped_type).  <a href="#2ccdc5ab3d59da403b2ad0f435f0599e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#5505c30b66a42d0e199fdfa3c9bfa128">insert</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> first, <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> last)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#90d048b87e0987976ea36959daed1e77">insert</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> where, const std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a>, <a class="el" href="class_data_t.html">value_type</a> &gt; &amp;val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associative Container method, we do not use hint, so pointless.  <a href="#90d048b87e0987976ea36959daed1e77"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#e57ff6dd1cb4dc347b892dfa87ea6613">erase</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes key unreachable, but usually does not reclaim nodes to memory pool.  <a href="#e57ff6dd1cb4dc347b892dfa87ea6613"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#d7adac82317fc7926555f5ca40a5fa7b">erase</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> it)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes key unreachable, but usually does not reclaim nodes to memory pool.  <a href="#d7adac82317fc7926555f5ca40a5fa7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#f946e03747ceb9b679b70b040c424e69">erase</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> first, <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a range of values - makes keys unreachable, but usually does not reclaim nodes to memory pool (currently just removes each in a loop, could try better wholesale node removal).  <a href="#f946e03747ceb9b679b70b040c424e69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#3c8c26880a8fd44ae8d40916c92be27e">swap</a> (<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a> &amp;other)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#c8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>

<tr><td colspan="2"><div class="groupHeader">Sorted Associative Container methods.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#dc204502ef1606c9daa4a613da6aacfb">find</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns const_iterator to key, or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a> if not found.  <a href="#dc204502ef1606c9daa4a613da6aacfb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#9c9766a96c492f3e9e5861d6b4f87387">find</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns mutable iterator to key, or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a> if not found.  <a href="#9c9766a96c492f3e9e5861d6b4f87387"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#373c61cca9b31735f4548b5b59b70184">lower_bound</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator to the first element in a map with a key value that is equal to or greater than that of the specified key.  <a href="#373c61cca9b31735f4548b5b59b70184"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#482b50e623a123f653e2a91f113a507b">upper_bound</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an iterator to the first element in a map with a key value that is greater than the specified key.  <a href="#482b50e623a123f653e2a91f113a507b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#31fbffbdf311ce68ec99f0aebab5c0ea">lower_bound</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#99609d25589437b30cb42dab922bfaa9">upper_bound</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#97bb054bc81e97ec55f0b539cdcbfcde">equal_range</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pair of <a class="el" href="namespaceiterators.html">iterators</a> respectively to the first element in a map with a key that is equal to or greater than the specified key, and a value that is greater than key.  <a href="#97bb054bc81e97ec55f0b539cdcbfcde"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>, <br>
<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#33c1ee0eb39360edec2a985301b9d631">equal_range</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#ddd4e2b6ff9c7bef508bc908caabb2d4">count</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns count of key values in tree - returns 0 or 1.  <a href="#ddd4e2b6ff9c7bef508bc908caabb2d4"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Structured Container search methods [deprecated]</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="anchor" name="tst_structsearch"></a> These searches are possible by storing key elements in strict weak ordering, anchored at beginning of keys. This allows sub-key searches, ie searching for keys with matching subparts (ie first and last letter of a four-letter string must match, or keys differing from search string in at most <em>n</em> letters).<p>
Complexity of sub-key searches are proportional to the "breadth" of the search. Specifying that more than about 10% of key elements may differ can lead to the search operation traversing large parts of the tree. The front anchoring of key elements also have the consequence that prefix matches are same cost as find operation (log in tree size), while suffix searches are linear in tree size. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#d3a2e52c87d13662bfc39c58e047a3b2">prefix_range</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a pair of <a class="el" href="namespaceiterators.html">iterators</a>, the first points to the first key that begins with the prefix (or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a>), the second to the string following the last string that begins with prefix.  <a href="#d3a2e52c87d13662bfc39c58e047a3b2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>, <br>
<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#84e2a726d652a89435d352e1b08c0d44">prefix_range</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;prefix) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class CharIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#63252eb2273c6824f50894652b99ed86">longest_match</a> (CharIter &amp;first, CharIter last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the longest key that matches the beginning of the key element range (or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a>, if none is found).  <a href="#63252eb2273c6824f50894652b99ed86"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class CharIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#1fb6ceb32f07c5bfce85d01748329d6f">longest_match</a> (CharIter &amp;first, CharIter last) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1search__results__list.html">search_results_list</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#54b320eb05861c3f1d371124b1f6dd14">create_search_results</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method for use with wrapper classes.  <a href="#54b320eb05861c3f1d371124b1f6dd14"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#8c63d4ad36f66355803cfcedec5f61ad">partial_match_search</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key, OutputIter results, <a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a> wildcard=wildcard_char) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Partial match search - supports wildcard characters (default: '?') Proxies for <a class="el" href="namespaceiterators.html">iterators</a> to the found strings are pushed at the output iterator.  <a href="#8c63d4ad36f66355803cfcedec5f61ad"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#271002d995ff11ea86157acfbbb32c70">hamming_search</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key, OutputIter results, <a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> dist) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hamming search: Finds all keys differing from <code>key</code> in at most <code>dist</code> characters (as an extension to strict hamming search, this includes matching but shorter/longer keys).  <a href="#271002d995ff11ea86157acfbbb32c70"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#1a065731747766b371dbc8b2dd13a5ea">levenshtein_search</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key, OutputIter results, <a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> dist) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Levenshtein search: Finds all strings differing from <code>key</code> in at most <code>dist</code> characters.  <a href="#1a065731747766b371dbc8b2dd13a5ea"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class OutputIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">OutputIter&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#8ec10f2049b8c459ad1c0f0ba9d41623">combinatorial_search</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key, OutputIter results, <a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> wildcards=0) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combinatorial, or "scrabble" search: Finds all keys containing the characters in the search string.  <a href="#8ec10f2049b8c459ad1c0f0ba9d41623"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Observers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><a class="el" href="classcontainers_1_1ternary__tree.html" title="Ternary search tree (trie) is a sorted container for strings, with advanced search...">ternary_tree</a> defines a <a class="el" href="classcontainers_1_1ternary__tree_1_1key__compare.html" title="Key comparator, defined in terms of a lexicographical_compare using the char_compare...">key_compare</a> class with same semantics as Sorted Associative Containers.<p>
Note that there is no value_compare type - the value_type does not contain the key. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#2d6d4cac1648493d6fe71c5e9ef6a3e3">char_comp</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the key element comparator object.  <a href="#2d6d4cac1648493d6fe71c5e9ef6a3e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree_1_1key__compare.html">key_compare</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#62c2add0ee33d7acce9f02077cd1da99">key_comp</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy of the <a class="el" href="classcontainers_1_1ternary__tree_1_1key__compare.html" title="Key comparator, defined in terms of a lexicographical_compare using the char_compare...">key_compare</a> class.  <a href="#62c2add0ee33d7acce9f02077cd1da99"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#546844ddc1b7c0805b66d6f5690191d9">node_count</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of nodes in tree.  <a href="#546844ddc1b7c0805b66d6f5690191d9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#ebf7d940e1615cf0f0e69e1849381af1">item_count</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns number of string-value pairs (alias for <a class="el" href="classcontainers_1_1ternary__tree.html#503ab01f6c0142145d3434f6924714e7">size()</a>).  <a href="#ebf7d940e1615cf0f0e69e1849381af1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#a1cb98c99c5fa5904f0a2ad698a7a299">total_key_length</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns sum of lengths of all keys inserted into tree.  <a href="#a1cb98c99c5fa5904f0a2ad698a7a299"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#43f41b55078277c8669c36f4edd30242">longest_key</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns length of longest key ever inserted into tree (if key was erased, this value is not updated).  <a href="#43f41b55078277c8669c36f4edd30242"></a><br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Container comparison.</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#fe264c2ee9666322d4eedf487e25a8fb">operator==</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a> &amp;other) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#1e1964ea89bf88f55526e84a61ea8991">operator&lt;</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a> &amp;other) const </td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#9086119510b22937a54fab8b98aa3c74">print_node</a> (std::ostream &amp;ostr, const <a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a> &amp;n)</td></tr>

<tr><td colspan="2"><br><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef std::basic_string<br>
&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>, std::char_traits<br>
&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a> &gt;, typename <br>
allocator_type::template <br>
rebind&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a> &gt;::other &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#5e2aa25bfa0e4f8ac92e14b0301fd6de">string_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for cached key, since key_type is only req to be Forward Container, and we need push_back(), pop_back() methods (in iterator and in a search method).  <a href="#5e2aa25bfa0e4f8ac92e14b0301fd6de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <br>
<a class="el" href="structcontainers_1_1tst__detail_1_1size__policy__node.html">tst_detail::size_policy_node</a><br>
&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>, <a class="el" href="class_data_t.html">mapped_type</a>, <br>
<a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>, <br>
TST_NODE_COUNT_TYPE &gt;<br>
::node_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Node size only configurable by code change and recompile (FIXME).  <a href="#5bb52130fee9136094463aaa56d641c2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#87f4f823df9b48e1c1ff0dbb7dce3ebd">last_item</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#169b6444c0d28d499fed9fb18294d70b">last_item</a> () const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#3f8d5cc35cbffbb149f8ca8ff5e5c9f5">less</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a> a, <a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a> b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">test characters for sort order.  <a href="#3f8d5cc35cbffbb149f8ca8ff5e5c9f5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class CharIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structcontainers_1_1ternary__tree_1_1find__result.html">find_result</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#554fff911aa25bba58d1685c5aa68832">find_impl</a> (CharIter &amp;first, CharIter last) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the iteration master service for insert and partial match, etc.  <a href="#554fff911aa25bba58d1685c5aa68832"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class CharIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#a9054a41cd10a28cc7e50b6a32a54fc4">insert_impl</a> (CharIter first, CharIter last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">insert chars, returns at_end node index  <a href="#a9054a41cd10a28cc7e50b6a32a54fc4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class CharIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#38565540c133f9fa415d936c93f3a674">insert_append</a> (<a class="el" href="structcontainers_1_1ternary__tree_1_1find__result.html">find_result</a> &amp;found, CharIter first, CharIter last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">append nodes to find_results point  <a href="#38565540c133f9fa415d936c93f3a674"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class CharIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#a08b69a9969dfdfdf427249e6e303037">subscript_insert</a> (CharIter first, CharIter last)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Support operator[].  <a href="#a08b69a9969dfdfdf427249e6e303037"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#ba8e2b4a496cb760bb8683bf0178614e">erase_impl</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> erasedindex, <a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> keylen)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns index of last disabled node (that could not be released).  <a href="#ba8e2b4a496cb760bb8683bf0178614e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#62da32065f19959015cc19d89f8908a1">lower_bound_impl</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#0ca03bfc66a0a9f7c25b9aeda65f6c35">upper_bound_impl</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>, <br>
<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#4386866ac8e76249cac748ab179445a0">equal_range_impl</a> (const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;key) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class CharIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>, <br>
<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#2e428f18905dd2c86c3b60c59fb591ba">prefix_range_impl</a> (CharIter first, CharIter last) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix match implementation  <a href="#2e428f18905dd2c86c3b60c59fb591ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class CharIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#9c119c36828973a5e22b2da0cac337fc">longest_match_impl</a> (CharIter &amp;first, CharIter last) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">longest match implementation  <a href="#9c119c36828973a5e22b2da0cac337fc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIter, class OutputIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#1a99feedd9893ae8da7c08a01c7c62c8">partial_match_search_impl</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> nid, InputIter first, InputIter last, OutputIter results, <a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a> wildcard) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">partial match search implementation  <a href="#1a99feedd9893ae8da7c08a01c7c62c8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIter, class OutputIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#b64789094a6771134ca2b9cd3cd4f022">hamming_search_impl</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> nid, InputIter first, InputIter last, OutputIter results, int dist) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hamming_search implementation  <a href="#b64789094a6771134ca2b9cd3cd4f022"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class InputIter, class OutputIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#4aa456fbb694eb9b4f903582be1fcefe">levenshtein_search_impl</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> nid, <a class="el" href="structcontainers_1_1tst__detail_1_1levenshtein__search__info.html">tst_detail::levenshtein_search_info</a>&lt; InputIter &gt; &amp;info, InputIter last, OutputIter results) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">levenshtein_search implementation  <a href="#4aa456fbb694eb9b4f903582be1fcefe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class String, class OutputIter&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#b6c7d71095230ce0163b9b43b6197158">combinatorial_search_impl</a> (<a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> nid, const String &amp;str, OutputIter results, <a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> jokers) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">combinatorial_search implementation  <a href="#b6c7d71095230ce0163b9b43b6197158"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#d881e5d84c7bb60a13cfa7c54df27507">NodeList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#e39c3efb5833053a71349afd3495ac04">m_nodes</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#f5cd48b0d690ee6e0e372e93fbd7d0d2">m_comparator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#4e5cb22a38ba17429f8b637a4f0d558c">m_allocator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#e9daca73dfa0a0ff8d4678f0cce15fe0">m_item_count</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keeps stats for tree insertion.  <a href="#e9daca73dfa0a0ff8d4678f0cce15fe0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#34b5ae3cc05a4a233bcce9645e848c91">m_total_key_length</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keeps stats for tree insertion.  <a href="#34b5ae3cc05a4a233bcce9645e848c91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#59a2c26ca96be0a8bd23d63c529ef785">m_longest_key</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keeps stats for tree insertion.  <a href="#59a2c26ca96be0a8bd23d63c529ef785"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_iterator_base</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#494f174aa191ae0984bc6d574aa21122">m_last_item</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index to last key endnode: must be maintained to have const-time reverse iteration.  <a href="#494f174aa191ae0984bc6d574aa21122"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#b6a85807b5898318a0e75f2c02d51510">tst_detail::tst_iterator_base&lt; NodeList, string_type &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">friend class tst_detail::tst_iterator_base&lt;StringT, DataT, CompT, AllocT&gt;;  <a href="#b6a85807b5898318a0e75f2c02d51510"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#31fddefafc5b221235c143258e059572">tst_detail::iter_method_forward&lt; ternary_tree &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Needed to construct <a class="el" href="namespaceiterators.html">iterators</a> for (eg) <a class="el" href="classcontainers_1_1structured__multimap.html" title="Structured Multimap is a Sorted Associative Container that stores objects of type...">structured_multimap</a>.  <a href="#31fddefafc5b221235c143258e059572"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#7838371567984763023a9f3e8a79bc97">search_results_list</a></td></tr>

<tr><td colspan="2"><br><h2>Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class S, class D, class C, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#3eb164dc6ea81c293050d1e7c6177a91">operator==</a> (<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;x, <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class S, class D, class C, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#c19233c17e011a1750ffd1b14bdc9798">operator!=</a> (<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;x, <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class S, class D, class C, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#d74363870e84b6179cbc68a925181341">operator&lt;</a> (<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;x, <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class S, class D, class C, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#39de83757af9185bae8fd84278f2afc5">operator&gt;</a> (<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;x, <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class S, class D, class C, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#6fc5226167164b8cbf27534f8ba55fb1">operator&lt;=</a> (<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;x, <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class S, class D, class C, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#0eb9c18a2ba6ec06af8186c0bd9c4e43">operator&gt;=</a> (<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;x, <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;y)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class S, class D, class C, class A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree.html#8cf9a643b36f958c1c7f9116b4a3229c">operator&lt;&lt;</a> (std::ostream &amp;ostr, typename <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a> const &amp;<a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a>)</td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcontainers_1_1ternary__tree_1_1find__result.html">find_result</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcontainers_1_1ternary__tree_1_1key__compare.html">key_compare</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Key comparator, defined in terms of a lexicographical_compare using the char_compare object.  <a href="classcontainers_1_1ternary__tree_1_1key__compare.html#_details">More...</a><br></td></tr>
</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="1f4361998cfc9666d5f9ec0829aae2cd"></a><!-- doxytag: member="containers::ternary_tree::key_type" ref="1f4361998cfc9666d5f9ec0829aae2cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef StringT <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b8257475bc306a2bb01737b5c6cbbd5f"></a><!-- doxytag: member="containers::ternary_tree::char_type" ref="b8257475bc306a2bb01737b5c6cbbd5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef StringT::value_type <a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="38ea2abd4850e417f10d666ef02d85ea"></a><!-- doxytag: member="containers::ternary_tree::char_compare" ref="38ea2abd4850e417f10d666ef02d85ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef CompT <a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="73698ab9694a30d494a8bbcf67cb1869"></a><!-- doxytag: member="containers::ternary_tree::value_type" ref="73698ab9694a30d494a8bbcf67cb1869" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_data_t.html">DataT</a> <a class="el" href="class_data_t.html">value_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="28abbceceb418e111143996599f65a2b"></a><!-- doxytag: member="containers::ternary_tree::mapped_type" ref="28abbceceb418e111143996599f65a2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_data_t.html">DataT</a> <a class="el" href="class_data_t.html">mapped_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="11115bca3c25be378d4e585ba447263d"></a><!-- doxytag: member="containers::ternary_tree::allocator_type" ref="11115bca3c25be378d4e585ba447263d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocT <a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ee486410786d79e33e01d73ea6cca7da"></a><!-- doxytag: member="containers::ternary_tree::pointer" ref="ee486410786d79e33e01d73ea6cca7da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocT::pointer <a class="el" href="classcontainers_1_1ternary__tree.html#ee486410786d79e33e01d73ea6cca7da">pointer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1fdba14c8cbdf2b890a371b866e21a4d"></a><!-- doxytag: member="containers::ternary_tree::const_pointer" ref="1fdba14c8cbdf2b890a371b866e21a4d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocT::const_pointer <a class="el" href="classcontainers_1_1ternary__tree.html#1fdba14c8cbdf2b890a371b866e21a4d">const_pointer</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fc70ed01177d84adef5112c04bebae10"></a><!-- doxytag: member="containers::ternary_tree::reference" ref="fc70ed01177d84adef5112c04bebae10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocT::reference <a class="el" href="classcontainers_1_1ternary__tree.html#fc70ed01177d84adef5112c04bebae10">reference</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3d091a348d155ec28fa408a61482055a"></a><!-- doxytag: member="containers::ternary_tree::const_reference" ref="3d091a348d155ec28fa408a61482055a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocT::const_reference <a class="el" href="classcontainers_1_1ternary__tree.html#3d091a348d155ec28fa408a61482055a">const_reference</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="970890daea8e5934937d6ac81aa3192c"></a><!-- doxytag: member="containers::ternary_tree::difference_type" ref="970890daea8e5934937d6ac81aa3192c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocT::difference_type <a class="el" href="classcontainers_1_1ternary__tree.html#970890daea8e5934937d6ac81aa3192c">difference_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0e2f0b11dd31316cec0e87f07653d7b8"></a><!-- doxytag: member="containers::ternary_tree::size_type" ref="0e2f0b11dd31316cec0e87f07653d7b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocT::size_type <a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5e2aa25bfa0e4f8ac92e14b0301fd6de"></a><!-- doxytag: member="containers::ternary_tree::string_type" ref="5e2aa25bfa0e4f8ac92e14b0301fd6de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::basic_string&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>, std::char_traits&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>&gt;, typename allocator_type::template rebind&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>&gt;::other &gt; <a class="el" href="classcontainers_1_1ternary__tree.html#5e2aa25bfa0e4f8ac92e14b0301fd6de">string_type</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Used for cached key, since key_type is only req to be Forward Container, and we need push_back(), pop_back() methods (in iterator and in a search method). 
<p>

</div>
</div><p>
<a class="anchor" name="5bb52130fee9136094463aaa56d641c2"></a><!-- doxytag: member="containers::ternary_tree::node" ref="5bb52130fee9136094463aaa56d641c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structcontainers_1_1tst__detail_1_1size__policy__node.html">tst_detail::size_policy_node</a>&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>, <a class="el" href="class_data_t.html">mapped_type</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>, TST_NODE_COUNT_TYPE &gt;::node_type <a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Node size only configurable by code change and recompile (FIXME). 
<p>
# typedef tst_detail::node&lt;char_type, mapped_type, allocator_type, size_type&gt; node; 
</div>
</div><p>
<a class="anchor" name="37eb606af3dc858ec309f49233ec89b0"></a><!-- doxytag: member="containers::ternary_tree::node_index" ref="37eb606af3dc858ec309f49233ec89b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef node::node_index <a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dependent type, defined by the macro <code>TST_NODE_COUNT_TYPE</code> (default: size_type). 
<p>

</div>
</div><p>
<a class="anchor" name="d881e5d84c7bb60a13cfa7c54df27507"></a><!-- doxytag: member="containers::ternary_tree::NodeList" ref="d881e5d84c7bb60a13cfa7c54df27507" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a>, typename allocator_type::template rebind&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a>&gt;::other&gt; <a class="el" href="classcontainers_1_1ternary__tree.html#d881e5d84c7bb60a13cfa7c54df27507">NodeList</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Impl note: nodes are stored in vector, effectively working as pool allocator. node_index vector offsets are used instead of pointers. 
<p>

</div>
</div><p>
<a class="anchor" name="fa33239da3bc144574b6858d80ce2630"></a><!-- doxytag: member="containers::ternary_tree::tst_iterator_base" ref="fa33239da3bc144574b6858d80ce2630" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_detail::tst_iterator_base</a>&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#d881e5d84c7bb60a13cfa7c54df27507">NodeList</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#5e2aa25bfa0e4f8ac92e14b0301fd6de">string_type</a>&gt; <a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_iterator_base</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
typedef tst_detail::tst_iterator_base&lt;StringT, DataT, CompT, AllocT&gt; tst_iterator_base; 
<p>

</div>
</div><p>
<a class="anchor" name="ea71cda3fda3290f9186dd6b332093e0"></a><!-- doxytag: member="containers::ternary_tree::iterator" ref="ea71cda3fda3290f9186dd6b332093e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TST_ITERATOR_FACADE_BEGIN <a class="el" href="structiterators_1_1iterator__wrapper.html">iterators::iterator_wrapper</a>&lt; <a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_iterator_base</a> , <a class="el" href="structiterators_1_1nonconst__traits.html">iterators::nonconst_traits</a>&lt;<a class="el" href="class_data_t.html">value_type</a>&gt; &gt; TST_ITERATOR_FACADE_END <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7a5946b69dea4a27e2aa8b37f03c2438"></a><!-- doxytag: member="containers::ternary_tree::const_iterator" ref="7a5946b69dea4a27e2aa8b37f03c2438" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TST_ITERATOR_FACADE_BEGIN <a class="el" href="structiterators_1_1iterator__wrapper.html">iterators::iterator_wrapper</a>&lt; <a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_iterator_base</a> , <a class="el" href="structiterators_1_1const__traits.html">iterators::const_traits</a>&lt;<a class="el" href="class_data_t.html">value_type</a>&gt; &gt; TST_ITERATOR_FACADE_END <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="92b881db836646f4039adcbb73c8595f"></a><!-- doxytag: member="containers::ternary_tree::reverse_iterator" ref="92b881db836646f4039adcbb73c8595f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&gt; <a class="el" href="classcontainers_1_1ternary__tree.html#92b881db836646f4039adcbb73c8595f">reverse_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="421ef78ccdc84f0f6b2b14e2732527ba"></a><!-- doxytag: member="containers::ternary_tree::const_reverse_iterator" ref="421ef78ccdc84f0f6b2b14e2732527ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::reverse_iterator&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&gt; <a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a14e9b3d5874f4cabce058df161bf01b"></a><!-- doxytag: member="containers::ternary_tree::search_results_list" ref="a14e9b3d5874f4cabce058df161bf01b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classcontainers_1_1search__results__list.html">search_results_list</a>&lt;<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&gt; <a class="el" href="classcontainers_1_1search__results__list.html">search_results_list</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="06fc87d81c62e9abb8790b6e5713c55b"></a><!-- doxytag: member="containers::ternary_tree::@0" ref="06fc87d81c62e9abb8790b6e5713c55b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default wildcard for partial_match_search. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="06fc87d81c62e9abb8790b6e5713c55bf7dbaf16b7f870b00de8e49e96928da7"></a><!-- doxytag: member="wildcard_char" ref="06fc87d81c62e9abb8790b6e5713c55bf7dbaf16b7f870b00de8e49e96928da7" args="" -->wildcard_char</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="b9b69c7ac4c5994a342e5c200fd3cc50"></a><!-- doxytag: member="containers::ternary_tree::ternary_tree" ref="b9b69c7ac4c5994a342e5c200fd3cc50" args="(const char_compare &amp;comp=char_compare(), const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>comp</em> = <code><a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code><a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c47c0d990e2e420e77b4ded99f23dd34"></a><!-- doxytag: member="containers::ternary_tree::ternary_tree" ref="c47c0d990e2e420e77b4ded99f23dd34" args="(InputIterator first, InputIterator last, const char_compare &amp;comp=char_compare(), const allocator_type &amp;alloc=allocator_type())" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>comp</em> = <code><a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code><a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a2321b9c15742d4173a3b3fd4493eb0f"></a><!-- doxytag: member="containers::ternary_tree::ternary_tree" ref="a2321b9c15742d4173a3b3fd4493eb0f" args="(const ternary_tree &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; StringT, <a class="el" href="class_data_t.html">DataT</a>, CompT, AllocT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a0b22184ad6609cad86b2127e34b606d"></a><!-- doxytag: member="containers::ternary_tree::~ternary_tree" ref="a0b22184ad6609cad86b2127e34b606d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="d592db3b95b56fcad5871af996008c39"></a><!-- doxytag: member="containers::ternary_tree::operator=" ref="d592db3b95b56fcad5871af996008c39" args="(const ternary_tree &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&amp; operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; StringT, <a class="el" href="class_data_t.html">DataT</a>, CompT, AllocT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cfbc5374e81f060b1cdffeb9c494ae86"></a><!-- doxytag: member="containers::ternary_tree::get_allocator" ref="cfbc5374e81f060b1cdffeb9c494ae86" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a> get_allocator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a copy of the allocator used to construct the tree. 
<p>

</div>
</div><p>
<a class="anchor" name="d69bd11391be1a1dba5c8202259664f8"></a><!-- doxytag: member="containers::ternary_tree::begin" ref="d69bd11391be1a1dba5c8202259664f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a4b02d4f1a8500fb07a551069060709f"></a><!-- doxytag: member="containers::ternary_tree::begin" ref="a4b02d4f1a8500fb07a551069060709f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cad38d52497a975bfb6f2f6acd76631f"></a><!-- doxytag: member="containers::ternary_tree::end" ref="cad38d52497a975bfb6f2f6acd76631f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="350132543d80a1c1e5be844e6d2878ea"></a><!-- doxytag: member="containers::ternary_tree::end" ref="350132543d80a1c1e5be844e6d2878ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cea44ed500a54b2bb93e16b86e81afa8"></a><!-- doxytag: member="containers::ternary_tree::rbegin" ref="cea44ed500a54b2bb93e16b86e81afa8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#92b881db836646f4039adcbb73c8595f">reverse_iterator</a> rbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="04886aa70c34d66738e78bf70c675e66"></a><!-- doxytag: member="containers::ternary_tree::rbegin" ref="04886aa70c34d66738e78bf70c675e66" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a> rbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="68c599ddcbfddc65170de524ac165e44"></a><!-- doxytag: member="containers::ternary_tree::rend" ref="68c599ddcbfddc65170de524ac165e44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#92b881db836646f4039adcbb73c8595f">reverse_iterator</a> rend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b3c414470d5cea2986cfab7a90146cb6"></a><!-- doxytag: member="containers::ternary_tree::rend" ref="b3c414470d5cea2986cfab7a90146cb6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a> rend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bcbe5a8d1c228764829c9826cfe48910"></a><!-- doxytag: member="containers::ternary_tree::cbegin" ref="bcbe5a8d1c228764829c9826cfe48910" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> cbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="02ed5283a097925e2c2f96e6daae6a80"></a><!-- doxytag: member="containers::ternary_tree::cend" ref="02ed5283a097925e2c2f96e6daae6a80" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> cend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d46fdce4a2ae356bce3b801db2bcc918"></a><!-- doxytag: member="containers::ternary_tree::crbegin" ref="d46fdce4a2ae356bce3b801db2bcc918" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a> crbegin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0ec903d2e9ea165b0460f1f6d40da203"></a><!-- doxytag: member="containers::ternary_tree::crend" ref="0ec903d2e9ea165b0460f1f6d40da203" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#421ef78ccdc84f0f6b2b14e2732527ba">const_reverse_iterator</a> crend           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c6e61de369e994009e36f344f99c15ad"></a><!-- doxytag: member="containers::ternary_tree::empty" ref="c6e61de369e994009e36f344f99c15ad" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="503ab01f6c0142145d3434f6924714e7"></a><!-- doxytag: member="containers::ternary_tree::size" ref="503ab01f6c0142145d3434f6924714e7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0ab5ce862c0331d9e45a6e1774fca131"></a><!-- doxytag: member="containers::ternary_tree::max_size" ref="0ab5ce862c0331d9e45a6e1774fca131" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> max_size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ed8a0df9b61494f55f08fd3c7f7189fb"></a><!-- doxytag: member="containers::ternary_tree::operator[]" ref="ed8a0df9b61494f55f08fd3c7f7189fb" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_data_t.html">mapped_type</a>&amp; operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a key into the tree and returns a mutable reference to its mapped_value. 
<p>

</div>
</div><p>
<a class="anchor" name="bb5f272154877b5de78b68f7a98a5bb4"></a><!-- doxytag: member="containers::ternary_tree::insert" ref="bb5f272154877b5de78b68f7a98a5bb4" args="(const std::pair&lt; key_type, value_type &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>, bool&gt; insert           </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a>, <a class="el" href="class_data_t.html">value_type</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pair whose bool component returns true if an insertion was made and false if the tree already contained an an equivalent key. 
<p>

</div>
</div><p>
<a class="anchor" name="2ccdc5ab3d59da403b2ad0f435f0599e"></a><!-- doxytag: member="containers::ternary_tree::insert" ref="2ccdc5ab3d59da403b2ad0f435f0599e" args="(InputIterator first, InputIterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert           </td>
          <td>(</td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a range from another <a class="el" href="classcontainers_1_1ternary__tree.html" title="Ternary search tree (trie) is a sorted container for strings, with advanced search...">ternary_tree</a> (or any iterator to pair with same key_type, mapped_type). 
<p>

</div>
</div><p>
<a class="anchor" name="5505c30b66a42d0e199fdfa3c9bfa128"></a><!-- doxytag: member="containers::ternary_tree::insert" ref="5505c30b66a42d0e199fdfa3c9bfa128" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="90d048b87e0987976ea36959daed1e77"></a><!-- doxytag: member="containers::ternary_tree::insert" ref="90d048b87e0987976ea36959daed1e77" args="(iterator where, const std::pair&lt; key_type, value_type &gt; &amp;val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> insert           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a>, <a class="el" href="class_data_t.html">value_type</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Associative Container method, we do not use hint, so pointless. 
<p>

</div>
</div><p>
<a class="anchor" name="e57ff6dd1cb4dc347b892dfa87ea6613"></a><!-- doxytag: member="containers::ternary_tree::erase" ref="e57ff6dd1cb4dc347b892dfa87ea6613" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> erase           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes key unreachable, but usually does not reclaim nodes to memory pool. 
<p>
Postcondition: find(key) returns <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a>. Does not invalidate any <a class="el" href="namespaceiterators.html">iterators</a> except those pointing to an erased element. If key exists, <a class="el" href="classcontainers_1_1ternary__tree.html#ebf7d940e1615cf0f0e69e1849381af1" title="Returns number of string-value pairs (alias for size()).">item_count()</a> is decremented; <a class="el" href="classcontainers_1_1ternary__tree.html#546844ddc1b7c0805b66d6f5690191d9" title="Returns number of nodes in tree.">node_count()</a> usually does not change. If <a class="el" href="classcontainers_1_1ternary__tree.html#503ab01f6c0142145d3434f6924714e7">size()</a> == 1, <a class="el" href="classcontainers_1_1ternary__tree.html#c8bb3912a3ce86b15842e79d0b421204">clear()</a> is called to wipe the slate clean. 
</div>
</div><p>
<a class="anchor" name="d7adac82317fc7926555f5ca40a5fa7b"></a><!-- doxytag: member="containers::ternary_tree::erase" ref="d7adac82317fc7926555f5ca40a5fa7b" args="(iterator it)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>it</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes key unreachable, but usually does not reclaim nodes to memory pool. 
<p>
Postcondition: find(key) returns <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a>. Does not invalidate any <a class="el" href="namespaceiterators.html">iterators</a> except those pointing to an erased element. If key exists, <a class="el" href="classcontainers_1_1ternary__tree.html#ebf7d940e1615cf0f0e69e1849381af1" title="Returns number of string-value pairs (alias for size()).">item_count()</a> is decremented; <a class="el" href="classcontainers_1_1ternary__tree.html#546844ddc1b7c0805b66d6f5690191d9" title="Returns number of nodes in tree.">node_count()</a> usually does not change. If <a class="el" href="classcontainers_1_1ternary__tree.html#503ab01f6c0142145d3434f6924714e7">size()</a> == 1, <a class="el" href="classcontainers_1_1ternary__tree.html#c8bb3912a3ce86b15842e79d0b421204">clear()</a> is called to wipe the slate clean. 
</div>
</div><p>
<a class="anchor" name="f946e03747ceb9b679b70b040c424e69"></a><!-- doxytag: member="containers::ternary_tree::erase" ref="f946e03747ceb9b679b70b040c424e69" args="(iterator first, iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> erase           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erases a range of values - makes keys unreachable, but usually does not reclaim nodes to memory pool (currently just removes each in a loop, could try better wholesale node removal). 
<p>
Returns iterator as per C++0x 
</div>
</div><p>
<a class="anchor" name="3c8c26880a8fd44ae8d40916c92be27e"></a><!-- doxytag: member="containers::ternary_tree::swap" ref="3c8c26880a8fd44ae8d40916c92be27e" args="(ternary_tree &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void swap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; StringT, <a class="el" href="class_data_t.html">DataT</a>, CompT, AllocT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c8bb3912a3ce86b15842e79d0b421204"></a><!-- doxytag: member="containers::ternary_tree::clear" ref="c8bb3912a3ce86b15842e79d0b421204" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="dc204502ef1606c9daa4a613da6aacfb"></a><!-- doxytag: member="containers::ternary_tree::find" ref="dc204502ef1606c9daa4a613da6aacfb" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns const_iterator to key, or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a> if not found. 
<p>

</div>
</div><p>
<a class="anchor" name="9c9766a96c492f3e9e5861d6b4f87387"></a><!-- doxytag: member="containers::ternary_tree::find" ref="9c9766a96c492f3e9e5861d6b4f87387" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> find           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns mutable iterator to key, or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a> if not found. 
<p>

</div>
</div><p>
<a class="anchor" name="373c61cca9b31735f4548b5b59b70184"></a><!-- doxytag: member="containers::ternary_tree::lower_bound" ref="373c61cca9b31735f4548b5b59b70184" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> lower_bound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator to the first element in a map with a key value that is equal to or greater than that of the specified key. 
<p>
If <em>key</em> exists, it is returned, else returns the element that has <em>key</em> for a prefix (or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a> if no such element exists).<p>
Complexity is that of a <a class="el" href="classcontainers_1_1ternary__tree.html#dc204502ef1606c9daa4a613da6aacfb" title="Returns const_iterator to key, or end() if not found.">find()</a> operation. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcontainers_1_1ternary__tree.html#d3a2e52c87d13662bfc39c58e047a3b2" title="Returns a pair of iterators, the first points to the first key that begins with the...">prefix_range</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="482b50e623a123f653e2a91f113a507b"></a><!-- doxytag: member="containers::ternary_tree::upper_bound" ref="482b50e623a123f653e2a91f113a507b" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> upper_bound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an iterator to the first element in a map with a key value that is greater than the specified key. 
<p>
If <em>key</em> exists, this returns ++key, else it returns the element that has <em>key</em> for a prefix (or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a> if no such element exists).<p>
Complexity is that of a <a class="el" href="classcontainers_1_1ternary__tree.html#dc204502ef1606c9daa4a613da6aacfb" title="Returns const_iterator to key, or end() if not found.">find()</a> operation + one iterator increment. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcontainers_1_1ternary__tree.html#d3a2e52c87d13662bfc39c58e047a3b2" title="Returns a pair of iterators, the first points to the first key that begins with the...">prefix_range</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="31fbffbdf311ce68ec99f0aebab5c0ea"></a><!-- doxytag: member="containers::ternary_tree::lower_bound" ref="31fbffbdf311ce68ec99f0aebab5c0ea" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> lower_bound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="99609d25589437b30cb42dab922bfaa9"></a><!-- doxytag: member="containers::ternary_tree::upper_bound" ref="99609d25589437b30cb42dab922bfaa9" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> upper_bound           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="97bb054bc81e97ec55f0b539cdcbfcde"></a><!-- doxytag: member="containers::ternary_tree::equal_range" ref="97bb054bc81e97ec55f0b539cdcbfcde" args="(const key_type &amp;key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&gt; equal_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pair of <a class="el" href="namespaceiterators.html">iterators</a> respectively to the first element in a map with a key that is equal to or greater than the specified key, and a value that is greater than key. 
<p>
The first is the lower_bound of the key, and the second is the upper_bound of the key.<p>
Complexity is that of a <a class="el" href="classcontainers_1_1ternary__tree.html#dc204502ef1606c9daa4a613da6aacfb" title="Returns const_iterator to key, or end() if not found.">find()</a> operation + one iterator increment. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcontainers_1_1ternary__tree.html#d3a2e52c87d13662bfc39c58e047a3b2" title="Returns a pair of iterators, the first points to the first key that begins with the...">prefix_range</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="33c1ee0eb39360edec2a985301b9d631"></a><!-- doxytag: member="containers::ternary_tree::equal_range" ref="33c1ee0eb39360edec2a985301b9d631" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&gt; equal_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ddd4e2b6ff9c7bef508bc908caabb2d4"></a><!-- doxytag: member="containers::ternary_tree::count" ref="ddd4e2b6ff9c7bef508bc908caabb2d4" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> count           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns count of key values in tree - returns 0 or 1. 
<p>

</div>
</div><p>
<a class="anchor" name="d3a2e52c87d13662bfc39c58e047a3b2"></a><!-- doxytag: member="containers::ternary_tree::prefix_range" ref="d3a2e52c87d13662bfc39c58e047a3b2" args="(const key_type &amp;prefix)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a>&gt; prefix_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a pair of <a class="el" href="namespaceiterators.html">iterators</a>, the first points to the first key that begins with the prefix (or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a>), the second to the string following the last string that begins with prefix. 
<p>
The first iterator is the lower_bound of the key, while the second is the first key that does not share the prefix. In a container with values { "aa", "aaa" "ab" }, equal_range("aa") returns { "aa", "aaa" }, while prefix_match returns { "aa", "ab" }. Worst-case complexity is that of two find(prefix) operations. <dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classcontainers_1_1ternary__tree.html#97bb054bc81e97ec55f0b539cdcbfcde" title="Returns a pair of iterators respectively to the first element in a map with a key...">equal_range</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="84e2a726d652a89435d352e1b08c0d44"></a><!-- doxytag: member="containers::ternary_tree::prefix_range" ref="84e2a726d652a89435d352e1b08c0d44" args="(const key_type &amp;prefix) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&gt; prefix_range           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>prefix</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="63252eb2273c6824f50894652b99ed86"></a><!-- doxytag: member="containers::ternary_tree::longest_match" ref="63252eb2273c6824f50894652b99ed86" args="(CharIter &amp;first, CharIter last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> longest_match           </td>
          <td>(</td>
          <td class="paramtype">CharIter &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the longest key that matches the beginning of the key element range (or <a class="el" href="classcontainers_1_1ternary__tree.html#cad38d52497a975bfb6f2f6acd76631f">end()</a>, if none is found). 
<p>
The key element iterator <em>first</em> is advanced to the element following the last matched character.<p>
(This method allows using the TST dictionary as a simple tokenizer over <em>first</em>, <em>last</em>.)<p>
Complexity is that of a single find operation. 
</div>
</div><p>
<a class="anchor" name="1fb6ceb32f07c5bfce85d01748329d6f"></a><!-- doxytag: member="containers::ternary_tree::longest_match" ref="1fb6ceb32f07c5bfce85d01748329d6f" args="(CharIter &amp;first, CharIter last) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> longest_match           </td>
          <td>(</td>
          <td class="paramtype">CharIter &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="54b320eb05861c3f1d371124b1f6dd14"></a><!-- doxytag: member="containers::ternary_tree::create_search_results" ref="54b320eb05861c3f1d371124b1f6dd14" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="classcontainers_1_1search__results__list.html">search_results_list</a> create_search_results           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Factory method for use with wrapper classes. 
<p>

</div>
</div><p>
<a class="anchor" name="8c63d4ad36f66355803cfcedec5f61ad"></a><!-- doxytag: member="containers::ternary_tree::partial_match_search" ref="8c63d4ad36f66355803cfcedec5f61ad" args="(const key_type &amp;key, OutputIter results, char_type wildcard=wildcard_char) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIter partial_match_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&nbsp;</td>
          <td class="paramname"> <em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>&nbsp;</td>
          <td class="paramname"> <em>wildcard</em> = <code>wildcard_char</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Partial match search - supports wildcard characters (default: '?') Proxies for <a class="el" href="namespaceiterators.html">iterators</a> to the found strings are pushed at the output iterator. 
<p>
A wildcard in search string entails visiting all subtrees of matched node(s). The worst-case complexity of partial match search is therefore O(m * k) * regular-find, where m is size of alphabet, k is number of wildcard characters in search string, and "regular-find" is lookup cost of the rest of the search string. In practice, only a fraction of the alphabet is present except near root level of the tree, but concrete performance is unpredictable. Typical timings are in order of 10 times find(key) per item returned. See article available at <a class="el" href="tst_links.html">Jon Bentley and Robert Sedgewick site </a>. 
</div>
</div><p>
<a class="anchor" name="271002d995ff11ea86157acfbbb32c70"></a><!-- doxytag: member="containers::ternary_tree::hamming_search" ref="271002d995ff11ea86157acfbbb32c70" args="(const key_type &amp;key, OutputIter results, size_type dist) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIter hamming_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&nbsp;</td>
          <td class="paramname"> <em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hamming search: Finds all keys differing from <code>key</code> in at most <code>dist</code> characters (as an extension to strict hamming search, this includes matching but shorter/longer keys). 
<p>
Proxies for <a class="el" href="namespaceiterators.html">iterators</a> to the found strings are pushed at the output iterator.<p>
Searches on values of dist &gt; 20% of average key length are typically expensive, since a large part of the tree is traversed (expensive may mean several microseconds per call). <dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://wikipedia.org/wiki/Hamming_distance">http://wikipedia.org/wiki/Hamming_distance</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1a065731747766b371dbc8b2dd13a5ea"></a><!-- doxytag: member="containers::ternary_tree::levenshtein_search" ref="1a065731747766b371dbc8b2dd13a5ea" args="(const key_type &amp;key, OutputIter results, size_type dist) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIter levenshtein_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&nbsp;</td>
          <td class="paramname"> <em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Levenshtein search: Finds all strings differing from <code>key</code> in at most <code>dist</code> characters. 
<p>
Proxies for <a class="el" href="namespaceiterators.html">iterators</a> to the found strings are pushed at the output iterator.<p>
Searches on values of dist &gt; 20% of average key length are typically expensive, since a large part of the tree is traversed (expensive may mean several microseconds per call). <dl class="see" compact><dt><b>See also:</b></dt><dd><a href="http://wikipedia.org/wiki/Levenshtein_distance">http://wikipedia.org/wiki/Levenshtein_distance</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ec10f2049b8c459ad1c0f0ba9d41623"></a><!-- doxytag: member="containers::ternary_tree::combinatorial_search" ref="8ec10f2049b8c459ad1c0f0ba9d41623" args="(const key_type &amp;key, OutputIter results, size_type wildcards=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIter combinatorial_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&nbsp;</td>
          <td class="paramname"> <em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>wildcards</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Combinatorial, or "scrabble" search: Finds all keys containing the characters in the search string. 
<p>
The optional wildcard count allows mismatch characters (use with care, it increases complexity of the search dramatically). 
</div>
</div><p>
<a class="anchor" name="2d6d4cac1648493d6fe71c5e9ef6a3e3"></a><!-- doxytag: member="containers::ternary_tree::char_comp" ref="2d6d4cac1648493d6fe71c5e9ef6a3e3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a> char_comp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a copy of the key element comparator object. 
<p>

</div>
</div><p>
<a class="anchor" name="62c2add0ee33d7acce9f02077cd1da99"></a><!-- doxytag: member="containers::ternary_tree::key_comp" ref="62c2add0ee33d7acce9f02077cd1da99" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree_1_1key__compare.html">key_compare</a> key_comp           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a copy of the <a class="el" href="classcontainers_1_1ternary__tree_1_1key__compare.html" title="Key comparator, defined in terms of a lexicographical_compare using the char_compare...">key_compare</a> class. 
<p>

</div>
</div><p>
<a class="anchor" name="546844ddc1b7c0805b66d6f5690191d9"></a><!-- doxytag: member="containers::ternary_tree::node_count" ref="546844ddc1b7c0805b66d6f5690191d9" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> node_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns number of nodes in tree. 
<p>

</div>
</div><p>
<a class="anchor" name="ebf7d940e1615cf0f0e69e1849381af1"></a><!-- doxytag: member="containers::ternary_tree::item_count" ref="ebf7d940e1615cf0f0e69e1849381af1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> item_count           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns number of string-value pairs (alias for <a class="el" href="classcontainers_1_1ternary__tree.html#503ab01f6c0142145d3434f6924714e7">size()</a>). 
<p>

</div>
</div><p>
<a class="anchor" name="a1cb98c99c5fa5904f0a2ad698a7a299"></a><!-- doxytag: member="containers::ternary_tree::total_key_length" ref="a1cb98c99c5fa5904f0a2ad698a7a299" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> total_key_length           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns sum of lengths of all keys inserted into tree. 
<p>

</div>
</div><p>
<a class="anchor" name="43f41b55078277c8669c36f4edd30242"></a><!-- doxytag: member="containers::ternary_tree::longest_key" ref="43f41b55078277c8669c36f4edd30242" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> longest_key           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns length of longest key ever inserted into tree (if key was erased, this value is not updated). 
<p>

</div>
</div><p>
<a class="anchor" name="fe264c2ee9666322d4eedf487e25a8fb"></a><!-- doxytag: member="containers::ternary_tree::operator==" ref="fe264c2ee9666322d4eedf487e25a8fb" args="(const ternary_tree &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; StringT, <a class="el" href="class_data_t.html">DataT</a>, CompT, AllocT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1e1964ea89bf88f55526e84a61ea8991"></a><!-- doxytag: member="containers::ternary_tree::operator&lt;" ref="1e1964ea89bf88f55526e84a61ea8991" args="(const ternary_tree &amp;other) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; StringT, <a class="el" href="class_data_t.html">DataT</a>, CompT, AllocT &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9086119510b22937a54fab8b98aa3c74"></a><!-- doxytag: member="containers::ternary_tree::print_node" ref="9086119510b22937a54fab8b98aa3c74" args="(std::ostream &amp;ostr, const node &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::ostream&amp; print_node           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="87f4f823df9b48e1c1ff0dbb7dce3ebd"></a><!-- doxytag: member="containers::ternary_tree::last_item" ref="87f4f823df9b48e1c1ff0dbb7dce3ebd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#ea71cda3fda3290f9186dd6b332093e0">iterator</a> last_item           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="169b6444c0d28d499fed9fb18294d70b"></a><!-- doxytag: member="containers::ternary_tree::last_item" ref="169b6444c0d28d499fed9fb18294d70b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> last_item           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3f8d5cc35cbffbb149f8ca8ff5e5c9f5"></a><!-- doxytag: member="containers::ternary_tree::less" ref="3f8d5cc35cbffbb149f8ca8ff5e5c9f5" args="(char_type a, char_type b) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
test characters for sort order. 
<p>

</div>
</div><p>
<a class="anchor" name="554fff911aa25bba58d1685c5aa68832"></a><!-- doxytag: member="containers::ternary_tree::find_impl" ref="554fff911aa25bba58d1685c5aa68832" args="(CharIter &amp;first, CharIter last) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="structcontainers_1_1ternary__tree_1_1find__result.html">find_result</a> find_impl           </td>
          <td>(</td>
          <td class="paramtype">CharIter &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the iteration master service for insert and partial match, etc. 
<p>
Ternary tree structure The insert_impl method defines primary tree structure.<p>
Returns a type that holds lookup result: index of the last matched node, and a pointer to a node index. If match was successful, <a class="el" href="structcontainers_1_1ternary__tree_1_1find__result.html#f394c3d4898ec72ec709e151a78d0295">find_result.pnid</a> is null, else it points to the hikid or lokid of the matched node that would point to first unmatched char if it were inserted.<p>
The difference from previous contents is inserted as a "twig", a stretch of nodes, and linked from the longest matching prefix. The resulting invariant is: if a char in search string matches a node char, there exists an adjacent next node with another char to test. The only exception is terminal nodes, ending a key, which have a special marker that ensures they cannot match any char in any possible key.<p>
find and iteration are defined to work with the resulting structure as best they can...<p>
This is mentioned due to the problem with erased nodes: When strings are erased, the invariant is broken, and must be mended with a special case: the erased-endnode. This is an endnode with a special marker. It must be silently bypassed by all parties, always taking the same path. 
</div>
</div><p>
<a class="anchor" name="a9054a41cd10a28cc7e50b6a32a54fc4"></a><!-- doxytag: member="containers::ternary_tree::insert_impl" ref="a9054a41cd10a28cc7e50b6a32a54fc4" args="(CharIter first, CharIter last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> insert_impl           </td>
          <td>(</td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
insert chars, returns at_end node index 
<p>

</div>
</div><p>
<a class="anchor" name="38565540c133f9fa415d936c93f3a674"></a><!-- doxytag: member="containers::ternary_tree::insert_append" ref="38565540c133f9fa415d936c93f3a674" args="(find_result &amp;found, CharIter first, CharIter last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> insert_append           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcontainers_1_1ternary__tree_1_1find__result.html">find_result</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>found</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
append nodes to find_results point 
<p>

</div>
</div><p>
<a class="anchor" name="a08b69a9969dfdfdf427249e6e303037"></a><!-- doxytag: member="containers::ternary_tree::subscript_insert" ref="a08b69a9969dfdfdf427249e6e303037" args="(CharIter first, CharIter last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> subscript_insert           </td>
          <td>(</td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Support operator[]. 
<p>

</div>
</div><p>
<a class="anchor" name="ba8e2b4a496cb760bb8683bf0178614e"></a><!-- doxytag: member="containers::ternary_tree::erase_impl" ref="ba8e2b4a496cb760bb8683bf0178614e" args="(node_index erasedindex, size_type keylen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> erase_impl           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td>
          <td class="paramname"> <em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>keylen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns index of last disabled node (that could not be released). 
<p>
Scan twig backward looking for branches, unlink all nodes that are not used.<p>
Three distinct cases:<ol type=1>
<li>zero branches: twig can be completely unlinked; the hikid/lokid pointer in twig root is set to invalid_index. Check that twig_root is still used, else erase it recursively.</li><li>one branch in all of twig. This in turn has two cases:<ul>
<li>branch occurs in first twig node: relink from twig_root.hi/lokid directly to branched node, then unlink twig.</li><li>branch occurs in subsequent twig node: close off branch node and erase subsequent twig nodes. If branch is in lokid, set branch node splitchar to zero and move link to hikid.</li></ul>
</li><li>two or more branches: Just mark branch node erased.</li></ol>
<p>
Finally, if erased nodes happen to be at very end of node vector, erase them from vector. If we wanted even more trouble, we could try to swap the erased nodes with last twig in tree.<p>
This is complicated, somewhat brittle code. 
</div>
</div><p>
<a class="anchor" name="62da32065f19959015cc19d89f8908a1"></a><!-- doxytag: member="containers::ternary_tree::lower_bound_impl" ref="62da32065f19959015cc19d89f8908a1" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> lower_bound_impl           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0ca03bfc66a0a9f7c25b9aeda65f6c35"></a><!-- doxytag: member="containers::ternary_tree::upper_bound_impl" ref="0ca03bfc66a0a9f7c25b9aeda65f6c35" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> upper_bound_impl           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4386866ac8e76249cac748ab179445a0"></a><!-- doxytag: member="containers::ternary_tree::equal_range_impl" ref="4386866ac8e76249cac748ab179445a0" args="(const key_type &amp;key) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>&gt; equal_range_impl           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcontainers_1_1ternary__tree.html#1f4361998cfc9666d5f9ec0829aae2cd">key_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2e428f18905dd2c86c3b60c59fb591ba"></a><!-- doxytag: member="containers::ternary_tree::prefix_range_impl" ref="2e428f18905dd2c86c3b60c59fb591ba" args="(CharIter first, CharIter last) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; typename <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a>, typename <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="classcontainers_1_1ternary__tree.html#7a5946b69dea4a27e2aa8b37f03c2438">const_iterator</a> &gt; prefix_range_impl           </td>
          <td>(</td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
prefix match implementation 
<p>

</div>
</div><p>
<a class="anchor" name="9c119c36828973a5e22b2da0cac337fc"></a><!-- doxytag: member="containers::ternary_tree::longest_match_impl" ref="9c119c36828973a5e22b2da0cac337fc" args="(CharIter &amp;first, CharIter last) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a> longest_match_impl           </td>
          <td>(</td>
          <td class="paramtype">CharIter &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CharIter&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
longest match implementation 
<p>

</div>
</div><p>
<a class="anchor" name="1a99feedd9893ae8da7c08a01c7c62c8"></a><!-- doxytag: member="containers::ternary_tree::partial_match_search_impl" ref="1a99feedd9893ae8da7c08a01c7c62c8" args="(node_index nid, InputIter first, InputIter last, OutputIter results, char_type wildcard) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void partial_match_search_impl           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td>
          <td class="paramname"> <em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&nbsp;</td>
          <td class="paramname"> <em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#b8257475bc306a2bb01737b5c6cbbd5f">char_type</a>&nbsp;</td>
          <td class="paramname"> <em>wildcard</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
partial match search implementation 
<p>
Repeats code from find_impl, recursive over hi-lo-eqkid when a wildcard char is matched. 
</div>
</div><p>
<a class="anchor" name="b64789094a6771134ca2b9cd3cd4f022"></a><!-- doxytag: member="containers::ternary_tree::hamming_search_impl" ref="b64789094a6771134ca2b9cd3cd4f022" args="(node_index nid, InputIter first, InputIter last, OutputIter results, int dist) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void hamming_search_impl           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td>
          <td class="paramname"> <em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&nbsp;</td>
          <td class="paramname"> <em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
hamming_search implementation 
<p>

</div>
</div><p>
<a class="anchor" name="4aa456fbb694eb9b4f903582be1fcefe"></a><!-- doxytag: member="containers::ternary_tree::levenshtein_search_impl" ref="4aa456fbb694eb9b4f903582be1fcefe" args="(node_index nid, tst_detail::levenshtein_search_info&lt; InputIter &gt; &amp;info, InputIter last, OutputIter results) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool levenshtein_search_impl           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td>
          <td class="paramname"> <em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcontainers_1_1tst__detail_1_1levenshtein__search__info.html">tst_detail::levenshtein_search_info</a>&lt; InputIter &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIter&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&nbsp;</td>
          <td class="paramname"> <em>results</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
levenshtein_search implementation 
<p>

</div>
</div><p>
<a class="anchor" name="b6c7d71095230ce0163b9b43b6197158"></a><!-- doxytag: member="containers::ternary_tree::combinatorial_search_impl" ref="b6c7d71095230ce0163b9b43b6197158" args="(node_index nid, const String &amp;str, OutputIter results, size_type jokers) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void combinatorial_search_impl           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#37eb606af3dc858ec309f49233ec89b0">node_index</a>&nbsp;</td>
          <td class="paramname"> <em>nid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const String &amp;&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIter&nbsp;</td>
          <td class="paramname"> <em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>jokers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, private]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
combinatorial_search implementation 
<p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="b6a85807b5898318a0e75f2c02d51510"></a><!-- doxytag: member="containers::ternary_tree::tst_detail::tst_iterator_base&lt; NodeList, string_type &gt;" ref="b6a85807b5898318a0e75f2c02d51510" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_detail::tst_iterator_base</a>&lt; <a class="el" href="classcontainers_1_1ternary__tree.html#d881e5d84c7bb60a13cfa7c54df27507">NodeList</a>, <a class="el" href="classcontainers_1_1ternary__tree.html#5e2aa25bfa0e4f8ac92e14b0301fd6de">string_type</a> &gt;<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
friend class tst_detail::tst_iterator_base&lt;StringT, DataT, CompT, AllocT&gt;; 
<p>

</div>
</div><p>
<a class="anchor" name="31fddefafc5b221235c143258e059572"></a><!-- doxytag: member="containers::ternary_tree::tst_detail::iter_method_forward&lt; ternary_tree &gt;" ref="31fddefafc5b221235c143258e059572" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structcontainers_1_1tst__detail_1_1iter__method__forward.html">tst_detail::iter_method_forward</a>&lt; <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a> &gt;<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Needed to construct <a class="el" href="namespaceiterators.html">iterators</a> for (eg) <a class="el" href="classcontainers_1_1structured__multimap.html" title="Structured Multimap is a Sorted Associative Container that stores objects of type...">structured_multimap</a>. 
<p>

</div>
</div><p>
<a class="anchor" name="7838371567984763023a9f3e8a79bc97"></a><!-- doxytag: member="containers::ternary_tree::search_results_list" ref="7838371567984763023a9f3e8a79bc97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classcontainers_1_1search__results__list.html">search_results_list</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3eb164dc6ea81c293050d1e7c6177a91"></a><!-- doxytag: member="containers::ternary_tree::operator==" ref="3eb164dc6ea81c293050d1e7c6177a91" args="(ternary_tree&lt; S, D, C, A &gt; const &amp;x, ternary_tree&lt; S, D, C, A &gt; const &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator==           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c19233c17e011a1750ffd1b14bdc9798"></a><!-- doxytag: member="containers::ternary_tree::operator!=" ref="c19233c17e011a1750ffd1b14bdc9798" args="(ternary_tree&lt; S, D, C, A &gt; const &amp;x, ternary_tree&lt; S, D, C, A &gt; const &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!=           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d74363870e84b6179cbc68a925181341"></a><!-- doxytag: member="containers::ternary_tree::operator&lt;" ref="d74363870e84b6179cbc68a925181341" args="(ternary_tree&lt; S, D, C, A &gt; const &amp;x, ternary_tree&lt; S, D, C, A &gt; const &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="39de83757af9185bae8fd84278f2afc5"></a><!-- doxytag: member="containers::ternary_tree::operator&gt;" ref="39de83757af9185bae8fd84278f2afc5" args="(ternary_tree&lt; S, D, C, A &gt; const &amp;x, ternary_tree&lt; S, D, C, A &gt; const &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6fc5226167164b8cbf27534f8ba55fb1"></a><!-- doxytag: member="containers::ternary_tree::operator&lt;=" ref="6fc5226167164b8cbf27534f8ba55fb1" args="(ternary_tree&lt; S, D, C, A &gt; const &amp;x, ternary_tree&lt; S, D, C, A &gt; const &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0eb9c18a2ba6ec06af8186c0bd9c4e43"></a><!-- doxytag: member="containers::ternary_tree::operator&gt;=" ref="0eb9c18a2ba6ec06af8186c0bd9c4e43" args="(ternary_tree&lt; S, D, C, A &gt; const &amp;x, ternary_tree&lt; S, D, C, A &gt; const &amp;y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt; const &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8cf9a643b36f958c1c7f9116b4a3229c"></a><!-- doxytag: member="containers::ternary_tree::operator&lt;&lt;" ref="8cf9a643b36f958c1c7f9116b4a3229c" args="(std::ostream &amp;ostr, typename ternary_tree&lt; S, D, C, A &gt;::node const &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>ostr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classcontainers_1_1ternary__tree.html">ternary_tree</a>&lt; S, D, C, A &gt;::<a class="el" href="classcontainers_1_1ternary__tree.html#5bb52130fee9136094463aaa56d641c2">node</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>node</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="e39c3efb5833053a71349afd3495ac04"></a><!-- doxytag: member="containers::ternary_tree::m_nodes" ref="e39c3efb5833053a71349afd3495ac04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#d881e5d84c7bb60a13cfa7c54df27507">NodeList</a> <a class="el" href="classcontainers_1_1ternary__tree.html#e39c3efb5833053a71349afd3495ac04">m_nodes</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f5cd48b0d690ee6e0e372e93fbd7d0d2"></a><!-- doxytag: member="containers::ternary_tree::m_comparator" ref="f5cd48b0d690ee6e0e372e93fbd7d0d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#38ea2abd4850e417f10d666ef02d85ea">char_compare</a> <a class="el" href="classcontainers_1_1ternary__tree.html#f5cd48b0d690ee6e0e372e93fbd7d0d2">m_comparator</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4e5cb22a38ba17429f8b637a4f0d558c"></a><!-- doxytag: member="containers::ternary_tree::m_allocator" ref="4e5cb22a38ba17429f8b637a4f0d558c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#11115bca3c25be378d4e585ba447263d">allocator_type</a> <a class="el" href="classcontainers_1_1ternary__tree.html#4e5cb22a38ba17429f8b637a4f0d558c">m_allocator</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e9daca73dfa0a0ff8d4678f0cce15fe0"></a><!-- doxytag: member="containers::ternary_tree::m_item_count" ref="e9daca73dfa0a0ff8d4678f0cce15fe0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> <a class="el" href="classcontainers_1_1ternary__tree.html#e9daca73dfa0a0ff8d4678f0cce15fe0">m_item_count</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keeps stats for tree insertion. 
<p>

</div>
</div><p>
<a class="anchor" name="34b5ae3cc05a4a233bcce9645e848c91"></a><!-- doxytag: member="containers::ternary_tree::m_total_key_length" ref="34b5ae3cc05a4a233bcce9645e848c91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> <a class="el" href="classcontainers_1_1ternary__tree.html#34b5ae3cc05a4a233bcce9645e848c91">m_total_key_length</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keeps stats for tree insertion. 
<p>

</div>
</div><p>
<a class="anchor" name="59a2c26ca96be0a8bd23d63c529ef785"></a><!-- doxytag: member="containers::ternary_tree::m_longest_key" ref="59a2c26ca96be0a8bd23d63c529ef785" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1ternary__tree.html#0e2f0b11dd31316cec0e87f07653d7b8">size_type</a> <a class="el" href="classcontainers_1_1ternary__tree.html#59a2c26ca96be0a8bd23d63c529ef785">m_longest_key</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Keeps stats for tree insertion. 
<p>

</div>
</div><p>
<a class="anchor" name="494f174aa191ae0984bc6d574aa21122"></a><!-- doxytag: member="containers::ternary_tree::m_last_item" ref="494f174aa191ae0984bc6d574aa21122" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcontainers_1_1tst__detail_1_1tst__iterator__base.html">tst_iterator_base</a> <a class="el" href="classcontainers_1_1ternary__tree.html#494f174aa191ae0984bc6d574aa21122">m_last_item</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Index to last key endnode: must be maintained to have const-time reverse iteration. 
<p>

</div>
</div><p>
</div>
<hr style="height: 3px; border-top: 0px; background-color: #e09060;">
<table width="100%"><tr style="color: #606080; font-size: 90%;" border="0">
<td><em>ternary_tree 0.68 -- by rasmus ekman
-- Page generated with <a href="http://doxygen.org">Doxygen 1.5.6</a> on 23 Jan 2009</em></td>
<td style="text-align: right; color:#f0f0ff;"><!--#exec cgi="/cgi-bin/counter"--></td>
</tr></table>
</body>
</html>
